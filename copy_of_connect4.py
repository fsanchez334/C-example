# -*- coding: utf-8 -*-
"""Copy of Connect4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16dKwMkmYdNTNrmZKU7ylLGNw-KjiMnWT

**For Students/Instructors:** In Lesson 1, we used the minimax algorithm to play Tic Tac Toe. 

Tic Tac Toe has a 3x3 board with 3 possible values for each space (X, O or blank). Excluding illegal combinations, there are 9! (362,880) possible games and 3<sup>9</sup> (19,683) possible boards. 

This is an upper limit since some boards are impossible and symmetrically similar boards can be treated as the same board, but even this upper board is computable. Since the state space of Tic Tac Toe is computable, we were able to search to the end of the game-tree in Lesson 1 and assign values (1, -1, and 0) to the outcome based on the three outcomes of the game (each player winning and a tie).

In this lab, we will be going through similar steps to play Connect 4! 

![connect4](https://drive.google.com/uc?id=1X6Mmo00qarojE1IN8oczbPjttsfGtGjW)

The standard Connect 4 board has height 6 and width 7 which comes out to [4,531,985,219,092](https://tromp.github.io/c4/c4.html) possible positions, which is **way** too big for us to search through each position.

Follow along with the lab to see how minimax is implemented for Connect 4!

**Instructor Notes:** Review Lesson 1 and the implementation with Tic Tac Toe if the student is unclear on the minimax algorithm.

In the following chunk of code, you have a starter Connect4 Class -  become familiar with it

Are you able to explain what each class method does?
"""

class Connect4:
  def __init__(self):
      self.height = 6
      self.width = 7
      self.connect = 4
      self.legal_players = ["X", "O"]
      self.reset()
     hey i am working LOL
        
  def reset(self):
      self.board = [[" " for _ in range(self.width)] for _ in range(self.height)]
      
  def __str__(self):
      # String representation of a game
      board = ""
      for r in range(self.height):
          board += "|"
          for c in range(self.width):
              board += "{}|".format(self.board[r][c])
          board += "\n"
      return board[:-1]

game = Connect4()
print(game)

"""#### **Step 2: Methods for Connect 4 Board Class**

Next, we have to write a few necessary methods for our board class to allow us to simulate Connect 4 game play. In this step, we will be writing


*   `__eq__()` to determine whether two boards are equal
*   `__hash__()` to give us a hash value for a game board object
*   `copy()` to copy the game board object
*   `get_moves()` to get the possible moves. Moves will be delineated by their column, so possible moves will be all columns that aren't full.


**TO DO:** Fill in the following starter code to complete these four methods (`__hash__` is already complete).

```
def __eq__(self, other):
    if isinstance(other, type(self)):
        return # Fill in
    return # Fill in

def __hash__(self):
    return hash("".join(sum(self.board,[])))

def copy(self):
    # Creates a copy of the game object
    # Fill in
    return new_board

def get_moves(self):
    # Check if top row filled
    # Fill in
```
"""

#TO DO
from copy import deepcopy

def __eq__(self, other):
  #This function determines whether two boards are equal
  if isinstance(other, type(self)):
    return self.board == other.board
  else:
    return False

def __hash__(self):
  return hash("".join(sum(self.board, [])))

def copy(self):
  #Creates a copy of the game object
  new_board = self.board.deepcopy()
  return new_board

def get_moves(self):
  container = []
  for idx, val in enumerate(self.board[0]):
    if val == " ":
      container.append(idx)
  return container

  #return [idx for idx, val in enumerate(self.board[0]) if val == " "] #Enhanced-For Loop

"""#### **Step 3: Methods for Connect 4 Class**

Look over the following three methods carefully `_is_match()`, `move()`, and `winner()`. These will be used in our Connect 4 class to insert a player's piece into the board provided it's a valid move and to check if a player has won the game.
"""

def _is_match(self, match):
    s_match = set(match)
    if len(s_match) == 1 and " " not in s_match:
        return match[0]

def move(self, player, c):
    player = player.upper()
    assert c in self.get_moves(), "Illegal move"
    assert player in self.legal_players, "Illegal player"
    move_row = 0
    for r in reversed(range(self.height)):
        if self.board[r][c] == " ":
            move_row = r
            break
    self.board[move_row][c] = player
    
def winner(self):
    # check horizontal
    for r in range(self.height):
        for c in range(self.width - self.connect + 1):
            match = [self.board[r][c+off] for off in range(self.connect)]
            if self._is_match(match) is not None:
                return match[0]
            
    # check vertical
    for r in range(self.height - self.connect + 1):
        for c in range(self.width):
            match = [self.board[r+off][c] for off in range(self.connect)]
            if self._is_match(match) is not None:
                return match[0]

    # check diagonal 
    for r in range(self.height - self.connect // 2 - 1):
        for c in range(self.width - self.connect // 2 - 1):
            # diagonal \
            match = [self.board[r + off][c + off] for off in range(self.connect)]
            if self._is_match(match) is not None:
                return match[0]
            # diagonal /
            match = [self.board[off][self.width - off - 1] for off in range(self.connect)]
            if self._is_match(match) is not None:
                return match[0]

"""**TO DO:** Now, write a method `score_game(self, player)` to score the game board object, 1 if the current player wins, -1 if the player loses, and 0 otherwise (there is no winner yet because we are not searching to the end of the game-tree or it is a draw). 

Write a second method `gameover(self)` that returns whether or not the game is over. The game ends when there are no more possible moves (i.e. a draw) or one player wins.
"""

def score_game(self, current_player):
  if self.winner() == current_player:
    return 1
  elif self.winner() != current_player:
    return -1
  return 0
  
def gameover(self):
  if len(self.get_moves()) == 0 or self.winner() is not None:
    return True
  return False

  #return len(self.get_moves()) == 0 or self.winner() is not None

class MinimaxBot:
  def __init__(self, time_penalty = -0.01, sub_optimal_weight = 0.1, limit =5):
    self.time_penalty = time_penalty
    self.memo = {} #saves the best move and score by player and game
    self.sub_optimal_weight = sub_optimal_weight
    self.limit = limit

  def play(self, game, player):
    return self.minimax(game, player)[0]

  def minimax(self, game, player, num_moves=0):
    pass
